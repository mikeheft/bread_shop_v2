# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `cancancan` gem.
# Please instead update this file by running `bin/tapioca gem cancancan`.

# this class is responsible of converting the hash of conditions
# in "where conditions" to generate the sql query
# it consists of a names_cache that helps calculating the next name given to the association
# it tries to reflect the bahavior of ActiveRecord when generating aliases for tables.
#
# source://cancancan//lib/cancan/version.rb#1
module CanCan; end

# This module is designed to be included into an Ability class. This will
# provide the "can" methods for defining and checking abilities.
#
#   class Ability
#     include CanCan::Ability
#
#     def initialize(user)
#       if user.admin?
#         can :manage, :all
#       else
#         can :read, :all
#       end
#     end
#   end
#
# source://cancancan//lib/cancan/ability/rules.rb#2
module CanCan::Ability
  include ::CanCan::Ability::Rules
  include ::CanCan::Ability::Actions

  # source://cancancan//lib/cancan/ability.rb#189
  def attributes_for(action, subject); end

  # See ControllerAdditions#authorize! for documentation.
  #
  # source://cancancan//lib/cancan/ability.rb#169
  def authorize!(action, subject, *args); end

  # Defines which abilities are allowed using two arguments. The first one is the action
  # you're setting the permission for, the second one is the class of object you're setting it on.
  #
  #   can :update, Article
  #
  # You can pass an array for either of these parameters to match any one.
  # Here the user has the ability to update or destroy both articles and comments.
  #
  #   can [:update, :destroy], [Article, Comment]
  #
  # You can pass :all to match any object and :manage to match any action. Here are some examples.
  #
  #   can :manage, :all
  #   can :update, :all
  #   can :manage, Project
  #
  # You can pass a hash of conditions as the third argument. Here the user can only see active projects which he owns.
  #
  #   can :read, Project, :active => true, :user_id => user.id
  #
  # See ActiveRecordAdditions#accessible_by for how to use this in database queries. These conditions
  # are also used for initial attributes when building a record in ControllerAdditions#load_resource.
  #
  # If the conditions hash does not give you enough control over defining abilities, you can use a block
  # along with any Ruby code you want.
  #
  #   can :update, Project do |project|
  #     project.groups.include?(user.group)
  #   end
  #
  # If the block returns true then the user has that :update ability for that project, otherwise he
  # will be denied access. The downside to using a block is that it cannot be used to generate
  # conditions for database queries.
  #
  # You can pass custom objects into this "can" method, this is usually done with a symbol
  # and is useful if a class isn't available to define permissions on.
  #
  #   can :read, :stats
  #   can? :read, :stats # => true
  #
  # IMPORTANT: Neither a hash of conditions nor a block will be used when checking permission on a class.
  #
  #   can :update, Project, :priority => 3
  #   can? :update, Project # => true
  #
  # If you pass no arguments to +can+, the action, class, and object will be passed to the block and the
  # block will always be executed. This allows you to override the full behavior if the permissions are
  # defined in an external source such as the database.
  #
  #   can do |action, object_class, object|
  #     # check the database and return true/false
  #   end
  #
  # source://cancancan//lib/cancan/ability.rb#137
  def can(action = T.unsafe(nil), subject = T.unsafe(nil), conditions = T.unsafe(nil), &block); end

  # Check if the user has permission to perform a given action on an object.
  #
  #   can? :destroy, @project
  #
  # You can also pass the class instead of an instance (if you don't have one handy).
  #
  #   can? :create, Project
  #
  # Nested resources can be passed through a hash, this way conditions which are
  # dependent upon the association will work when using a class.
  #
  #   can? :create, @category => Project
  #
  # You can also pass multiple objects to check. You only need to pass a hash
  # following the pattern { :any => [many subjects] }. The behaviour is check if
  # there is a permission on any of the given objects.
  #
  #   can? :create, {:any => [Project, Rule]}
  #
  #
  # Any additional arguments will be passed into the "can" block definition. This
  # can be used to pass more information about the user's request for example.
  #
  #   can? :create, Project, request.remote_ip
  #
  #   can :create, Project do |project, remote_ip|
  #     # ...
  #   end
  #
  # Not only can you use the can? method in the controller and view (see ControllerAdditions),
  # but you can also call it directly on an ability instance.
  #
  #   ability.can? :destroy, @project
  #
  # This makes testing a user's abilities very easy.
  #
  #   def test "user can only destroy projects which he owns"
  #     user = User.new
  #     ability = Ability.new(user)
  #     assert ability.can?(:destroy, Project.new(:user => user))
  #     assert ability.cannot?(:destroy, Project.new)
  #   end
  #
  # Also see the RSpec Matchers to aid in testing.
  #
  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/ability.rb#67
  def can?(action, subject, *extra_args); end

  # Defines an ability which cannot be done. Accepts the same arguments as "can".
  #
  #   can :read, :all
  #   cannot :read, Comment
  #
  # A block can be passed just like "can", however if the logic is complex it is recommended
  # to use the "can" method.
  #
  #   cannot :read, Product do |product|
  #     product.invisible?
  #   end
  #
  # source://cancancan//lib/cancan/ability.rb#153
  def cannot(action = T.unsafe(nil), subject = T.unsafe(nil), conditions = T.unsafe(nil), &block); end

  # Convenience method which works the same as "can?" but returns the opposite value.
  #
  #   cannot? :destroy, @project
  #
  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/ability.rb#80
  def cannot?(*args); end

  # source://cancancan//lib/cancan/ability.rb#250
  def extract_rule_in_permissions(permissions_list, rule); end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/ability.rb#197
  def has_block?(action, subject); end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/ability.rb#201
  def has_raw_sql?(action, subject); end

  # Copies all rules of the given +CanCan::Ability+ and adds them to +self+.
  #   class ReadAbility
  #     include CanCan::Ability
  #
  #     def initialize
  #       can :read, User
  #     end
  #   end
  #
  #   class WritingAbility
  #     include CanCan::Ability
  #
  #     def initialize
  #       can :edit, User
  #     end
  #   end
  #
  #   read_ability = ReadAbility.new
  #   read_ability.can? :edit, User.new #=> false
  #   read_ability.merge(WritingAbility.new)
  #   read_ability.can? :edit, User.new #=> true
  #
  # source://cancancan//lib/cancan/ability.rb#227
  def merge(ability); end

  # source://cancancan//lib/cancan/ability.rb#163
  def model_adapter(model_class, action); end

  # Return a hash of permissions for the user in the format of:
  #   {
  #     can: can_hash,
  #     cannot: cannot_hash
  #   }
  #
  # Where can_hash and cannot_hash are formatted thusly:
  #   {
  #     action: array_of_objects
  #   }
  #
  # source://cancancan//lib/cancan/ability.rb#244
  def permissions; end

  # source://cancancan//lib/cancan/ability.rb#181
  def unauthorized_message(action, subject); end

  # User shouldn't specify targets with names of real actions or it will cause Seg fault
  #
  # @raise [Error]
  #
  # source://cancancan//lib/cancan/ability.rb#158
  def validate_target(target); end

  private

  # source://cancancan//lib/cancan/ability.rb#277
  def alternative_subjects(subject); end

  # It translates to an array the subject or the hash with multiple subjects given to can?.
  #
  # source://cancancan//lib/cancan/ability.rb#269
  def extract_subjects(subject); end

  # source://cancancan//lib/cancan/ability.rb#260
  def unauthorized_message_keys(action, subject); end
end

# source://cancancan//lib/cancan/ability/actions.rb#3
module CanCan::Ability::Actions
  # Alias one or more actions into another one.
  #
  #   alias_action :update, :destroy, :to => :modify
  #   can :modify, Comment
  #
  # Then :modify permission will apply to both :update and :destroy requests.
  #
  #   can? :update, Comment # => true
  #   can? :destroy, Comment # => true
  #
  # This only works in one direction. Passing the aliased action into the "can?" call
  # will not work because aliases are meant to generate more generic actions.
  #
  #   alias_action :update, :destroy, :to => :modify
  #   can :update, Comment
  #   can? :modify, Comment # => false
  #
  # Unless that exact alias is used.
  #
  #   can :modify, Comment
  #   can? :modify, Comment # => true
  #
  # The following aliases are added by default for conveniently mapping common controller actions.
  #
  #   alias_action :index, :show, :to => :read
  #   alias_action :new, :to => :create
  #   alias_action :edit, :to => :update
  #
  # This way one can use params[:action] in the controller to determine the permission.
  #
  # source://cancancan//lib/cancan/ability/actions.rb#33
  def alias_action(*args); end

  # Returns a hash of aliased actions. The key is the target and the value is an array of actions aliasing the key.
  #
  # source://cancancan//lib/cancan/ability/actions.rb#41
  def aliased_actions; end

  # Removes previously aliased actions including the defaults.
  #
  # source://cancancan//lib/cancan/ability/actions.rb#46
  def clear_aliased_actions; end

  private

  # Given an action, it will try to find all of the actions which are aliased to it.
  # This does the opposite kind of lookup as expand_actions.
  #
  # source://cancancan//lib/cancan/ability/actions.rb#62
  def aliases_for_action(action); end

  # source://cancancan//lib/cancan/ability/actions.rb#52
  def default_alias_actions; end

  # Accepts an array of actions and returns an array of actions which match.
  # This should be called before "matches?" and other checking methods since they
  # rely on the actions to be expanded.
  #
  # source://cancancan//lib/cancan/ability/actions.rb#77
  def expand_actions(actions); end

  # source://cancancan//lib/cancan/ability/actions.rb#70
  def expanded_actions; end
end

# source://cancancan//lib/cancan/ability/rules.rb#3
module CanCan::Ability::Rules
  protected

  # Must be protected as an ability can merge with other abilities.
  # This means that an ability must expose their rules with another ability.
  #
  # source://cancancan//lib/cancan/ability/rules.rb#8
  def rules; end

  private

  # source://cancancan//lib/cancan/ability/rules.rb#14
  def add_rule(rule); end

  # source://cancancan//lib/cancan/ability/rules.rb#19
  def add_rule_to_index(rule, position); end

  # Optimizes the order of the rules, so that rules with the :all subject are evaluated first.
  #
  # source://cancancan//lib/cancan/ability/rules.rb#72
  def optimize_order!(rules); end

  # source://cancancan//lib/cancan/ability/rules.rb#43
  def possible_relevant_rules(subject); end

  # Returns an array of Rule instances which match the action and subject
  # This does not take into consideration any hash conditions or block statements
  #
  # source://cancancan//lib/cancan/ability/rules.rb#32
  def relevant_rules(action, subject); end

  # source://cancancan//lib/cancan/ability/rules.rb#53
  def relevant_rules_for_match(action, subject); end

  # source://cancancan//lib/cancan/ability/rules.rb#62
  def relevant_rules_for_query(action, subject); end
end

# This error is raised when a user isn't allowed to access a given controller action.
# This usually happens within a call to ControllerAdditions#authorize! but can be
# raised manually.
#
#   raise CanCan::AccessDenied.new("Not authorized!", :read, Article)
#
# The passed message, action, and subject are optional and can later be retrieved when
# rescuing from the exception.
#
#   exception.message # => "Not authorized!"
#   exception.action # => :read
#   exception.subject # => Article
#
# If the message is not specified (or is nil) it will default to "You are not authorized
# to access this page." This default can be overridden by setting default_message.
#
#   exception.default_message = "Default error message"
#   exception.message # => "Default error message"
#
# See ControllerAdditions#authorized! for more information on rescuing from this exception
# and customizing the message using I18n.
#
# source://cancancan//lib/cancan/exceptions.rb#38
class CanCan::AccessDenied < ::CanCan::Error
  # @return [AccessDenied] a new instance of AccessDenied
  #
  # source://cancancan//lib/cancan/exceptions.rb#42
  def initialize(message = T.unsafe(nil), action = T.unsafe(nil), subject = T.unsafe(nil), conditions = T.unsafe(nil)); end

  # Returns the value of attribute action.
  #
  # source://cancancan//lib/cancan/exceptions.rb#39
  def action; end

  # Returns the value of attribute conditions.
  #
  # source://cancancan//lib/cancan/exceptions.rb#39
  def conditions; end

  # Sets the attribute default_message
  #
  # @param value the value to set the attribute default_message to.
  #
  # source://cancancan//lib/cancan/exceptions.rb#40
  def default_message=(_arg0); end

  # Returns the value of attribute subject.
  #
  # source://cancancan//lib/cancan/exceptions.rb#39
  def subject; end

  # source://cancancan//lib/cancan/exceptions.rb#50
  def to_s; end
end

# Raised when using check_authorization without calling authorized!
#
# source://cancancan//lib/cancan/exceptions.rb#12
class CanCan::AuthorizationNotPerformed < ::CanCan::Error; end

# source://cancancan//lib/cancan/conditions_matcher.rb#2
module CanCan::ConditionsMatcher
  # Matches the block or conditions hash
  #
  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/conditions_matcher.rb#4
  def matches_conditions?(action, subject, extra_args); end

  private

  # source://cancancan//lib/cancan/conditions_matcher.rb#77
  def call_block_with_all(action, subject, extra_args); end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/conditions_matcher.rb#56
  def condition_match?(attribute, value); end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/conditions_matcher.rb#89
  def conditions_empty?; end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/conditions_matcher.rb#69
  def hash_condition_match?(attribute, value); end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/conditions_matcher.rb#46
  def matches_all_conditions?(adapter, conditions, subject); end

  # Checks if the given subject matches the given conditions hash.
  # This behavior can be overriden by a model adapter by defining two class methods:
  # override_matching_for_conditions?(subject, conditions) and
  # matches_conditions_hash?(subject, conditions)
  #
  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/conditions_matcher.rb#35
  def matches_conditions_hash?(subject, conditions = T.unsafe(nil)); end

  # source://cancancan//lib/cancan/conditions_matcher.rb#17
  def matches_non_block_conditions(subject); end

  # source://cancancan//lib/cancan/conditions_matcher.rb#85
  def model_adapter(subject); end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/conditions_matcher.rb#26
  def nested_subject_matches_conditions?(subject_hash); end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/conditions_matcher.rb#12
  def subject_class?(subject); end
end

# This module is automatically included into all controllers.
# It also makes the "can?" and "cannot?" methods available to all views.
#
# source://cancancan//lib/cancan/controller_additions.rb#4
module CanCan::ControllerAdditions
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::CanCan::ControllerAdditions::ClassMethods

  # Raises a CanCan::AccessDenied exception if the current_ability cannot
  # perform the given action. This is usually called in a controller action or
  # before filter to perform the authorization.
  #
  #   def show
  #     @article = Article.find(params[:id])
  #     authorize! :read, @article
  #   end
  #
  # A :message option can be passed to specify a different message.
  #
  #   authorize! :read, @article, :message => "Not authorized to read #{@article.name}"
  #
  # You can also use I18n to customize the message. Action aliases defined in Ability work here.
  #
  #   en:
  #     unauthorized:
  #       manage:
  #         all: "Not authorized to %{action} %{subject}."
  #         user: "Not allowed to manage other user accounts."
  #       update:
  #         project: "Not allowed to update this project."
  #
  # You can rescue from the exception in the controller to customize how unauthorized
  # access is displayed to the user.
  #
  #   class ApplicationController < ActionController::Base
  #     rescue_from CanCan::AccessDenied do |exception|
  #       redirect_to root_url, :alert => exception.message
  #     end
  #   end
  #
  # See the CanCan::AccessDenied exception for more details on working with the exception.
  #
  # See the load_and_authorize_resource method to automatically add the authorize! behavior
  # to the default RESTful actions.
  #
  # source://cancancan//lib/cancan/controller_additions.rb#334
  def authorize!(*args); end

  # Use in the controller or view to check the user's permission for a given action
  # and object.
  #
  #   can? :destroy, @project
  #
  # You can also pass the class instead of an instance (if you don't have one handy).
  #
  #   <% if can? :create, Project %>
  #     <%= link_to "New Project", new_project_path %>
  #   <% end %>
  #
  # If it's a nested resource, you can pass the parent instance in a hash. This way it will
  # check conditions which reach through that association.
  #
  #   <% if can? :create, @category => Project %>
  #     <%= link_to "New Project", new_project_path %>
  #   <% end %>
  #
  # This simply calls "can?" on the current_ability. See Ability#can?.
  #
  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/controller_additions.rb#373
  def can?(*args); end

  # Convenience method which works the same as "can?" but returns the opposite value.
  #
  #   cannot? :destroy, @project
  #
  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/controller_additions.rb#381
  def cannot?(*args); end

  # Creates and returns the current user's ability and caches it. If you
  # want to override how the Ability is defined then this is the place.
  # Just define the method in the controller to change behavior.
  #
  #   def current_ability
  #     # instead of Ability.new(current_user)
  #     @current_ability ||= UserAbility.new(current_account)
  #   end
  #
  # Notice it is important to cache the ability object so it is not
  # recreated every time.
  #
  # source://cancancan//lib/cancan/controller_additions.rb#350
  def current_ability; end

  class << self
    # @private
    #
    # source://cancancan//lib/cancan/controller_additions.rb#292
    def included(base); end
  end

  module GeneratedClassMethods
    def _cancan_skipper; end
    def _cancan_skipper=(value); end
    def _cancan_skipper?; end
  end

  module GeneratedInstanceMethods
    def _cancan_skipper; end
    def _cancan_skipper=(value); end
    def _cancan_skipper?; end
  end
end

# source://cancancan//lib/cancan/controller_additions.rb#5
module CanCan::ControllerAdditions::ClassMethods
  # Sets up a before filter which authorizes the resource using the instance variable.
  # For example, if you have an ArticlesController it will check the @article instance variable
  # and ensure the user can perform the current action on it. Under the hood it is doing
  # something like the following.
  #
  #   authorize!(params[:action].to_sym, @article || Article)
  #
  # Call this method directly on the controller class.
  #
  #   class BooksController < ApplicationController
  #     authorize_resource
  #   end
  #
  # If you pass in the name of a resource which does not match the controller it will assume
  # it is a parent resource.
  #
  #   class BooksController < ApplicationController
  #     authorize_resource :author
  #     authorize_resource :book
  #   end
  #
  # Here it will authorize :+show+, @+author+ on every action before authorizing the book.
  #
  # That first argument is optional and will default to the singular name of the controller.
  # A hash of options (see below) can also be passed to this method to further customize it.
  #
  # See load_and_authorize_resource to automatically load the resource too.
  #
  # Options:
  # [:+only+]
  #   Only applies before filter to given actions.
  #
  # [:+except+]
  #   Does not apply before filter to given actions.
  #
  # [:+singleton+]
  #   Pass +true+ if this is a singleton resource through a +has_one+ association.
  #
  # [:+parent+]
  #   True or false depending on if the resource is considered a parent resource.
  #   This defaults to +true+ if a resource name is given which does not match the controller.
  #
  # [:+class+]
  #   The class to use for the model (string or constant). This passed in when the instance variable is not set.
  #   Pass +false+ if there is no associated class for this resource and it will use a symbol of the resource name.
  #
  # [:+instance_name+]
  #   The name of the instance variable for this resource.
  #
  # [:+through+]
  #   Authorize conditions on this parent resource when instance isn't available.
  #
  # [:+prepend+]
  #   Passing +true+ will use prepend_before_action instead of a normal before_action.
  #
  # source://cancancan//lib/cancan/controller_additions.rb#178
  def authorize_resource(*args); end

  # source://cancancan//lib/cancan/controller_additions.rb#283
  def cancan_resource_class; end

  # source://cancancan//lib/cancan/controller_additions.rb#287
  def cancan_skipper; end

  # Add this to a controller to ensure it performs authorization through +authorized+! or +authorize_resource+ call.
  # If neither of these authorization methods are called,
  # a CanCan::AuthorizationNotPerformed exception will be raised.
  # This is normally added to the ApplicationController to ensure all controller actions do authorization.
  #
  #   class ApplicationController < ActionController::Base
  #     check_authorization
  #   end
  #
  # See skip_authorization_check to bypass this check on specific controller actions.
  #
  # Options:
  # [:+only+]
  #   Only applies to given actions.
  #
  # [:+except+]
  #   Does not apply to given actions.
  #
  # [:+if+]
  #   Supply the name of a controller method to be called.
  #   The authorization check only takes place if this returns true.
  #
  #     check_authorization :if => :admin_controller?
  #
  # [:+unless+]
  #   Supply the name of a controller method to be called.
  #   The authorization check only takes place if this returns false.
  #
  #     check_authorization :unless => :devise_controller?
  #
  # source://cancancan//lib/cancan/controller_additions.rb#258
  def check_authorization(options = T.unsafe(nil)); end

  # Sets up a before filter which loads and authorizes the current resource. This performs both
  # load_resource and authorize_resource and accepts the same arguments. See those methods for details.
  #
  #   class BooksController < ApplicationController
  #     load_and_authorize_resource
  #   end
  #
  # source://cancancan//lib/cancan/controller_additions.rb#13
  def load_and_authorize_resource(*args); end

  # Sets up a before filter which loads the model resource into an instance variable.
  # For example, given an ArticlesController it will load the current article into the @article
  # instance variable. It does this by either calling Article.find(params[:id]) or
  # Article.new(params[:article]) depending upon the action. The index action will
  # automatically set @articles to Article.accessible_by(current_ability).
  #
  # If a conditions hash is used in the Ability, the +new+ and +create+ actions will set
  # the initial attributes based on these conditions. This way these actions will satisfy
  # the ability restrictions.
  #
  # Call this method directly on the controller class.
  #
  #   class BooksController < ApplicationController
  #     load_resource
  #   end
  #
  # A resource is not loaded if the instance variable is already set. This makes it easy to override
  # the behavior through a before_action on certain actions.
  #
  #   class BooksController < ApplicationController
  #     before_action :find_book_by_permalink, :only => :show
  #     load_resource
  #
  #     private
  #
  #     def find_book_by_permalink
  #       @book = Book.find_by_permalink!(params[:id])
  #     end
  #   end
  #
  # If a name is provided which does not match the controller it assumes it is a parent resource. Child
  # resources can then be loaded through it.
  #
  #   class BooksController < ApplicationController
  #     load_resource :author
  #     load_resource :book, :through => :author
  #   end
  #
  # Here the author resource will be loaded before each action using params[:author_id]. The book resource
  # will then be loaded through the @author instance variable.
  #
  # That first argument is optional and will default to the singular name of the controller.
  # A hash of options (see below) can also be passed to this method to further customize it.
  #
  # See load_and_authorize_resource to automatically authorize the resource too.
  #
  # Options:
  # [:+only+]
  #   Only applies before filter to given actions.
  #
  # [:+except+]
  #   Does not apply before filter to given actions.
  #
  # [:+through+]
  #   Load this resource through another one. This should match the name of the parent instance variable or method.
  #
  # [:+through_association+]
  #   The name of the association to fetch the child records through the parent resource.
  #   This is normally not needed because it defaults to the pluralized resource name.
  #
  # [:+shallow+]
  #   Pass +true+ to allow this resource to be loaded directly when parent is +nil+. Defaults to +false+.
  #
  # [:+singleton+]
  #   Pass +true+ if this is a singleton resource through a +has_one+ association.
  #
  # [:+parent+]
  #   True or false depending on if the resource is considered a parent resource.
  #   This defaults to +true+ if a resource name is given which does not match the controller.
  #
  # [:+class+]
  #   The class to use for the model (string or constant).
  #
  # [:+instance_name+]
  #   The name of the instance variable to load the resource into.
  #
  # [:+find_by+]
  #   Find using a different attribute other than id. For example.
  #
  #     load_resource :find_by => :permalink # will use find_by_permalink!(params[:id])
  #
  # [:+id_param+]
  #   Find using a param key other than :id. For example:
  #
  #     load_resource :id_param => :url # will use find(params[:url])
  #
  # [:+collection+]
  #   Specify which actions are resource collection actions in addition to :+index+. This
  #   is usually not necessary because it will try to guess depending on if the id param is present.
  #
  #     load_resource :collection => [:sort, :list]
  #
  # [:+new+]
  #   Specify which actions are new resource actions in addition to :+new+ and :+create+.
  #   Pass an action name into here if you would like to build a new resource instead of
  #   fetch one.
  #
  #     load_resource :new => :build
  #
  # [:+prepend+]
  #   Passing +true+ will use prepend_before_action instead of a normal before_action.
  #
  # source://cancancan//lib/cancan/controller_additions.rb#119
  def load_resource(*args); end

  # Call this in the class of a controller to skip the check_authorization behavior on the actions.
  #
  #   class HomeController < ApplicationController
  #     skip_authorization_check :only => :index
  #   end
  #
  # Any arguments are passed to the +before_action+ it triggers.
  #
  # source://cancancan//lib/cancan/controller_additions.rb#278
  def skip_authorization_check(*args); end

  # Skip the authorization behavior of CanCan. This is useful when using +load_and_authorize_resource+ but want to
  # only do loading on certain actions. You can pass :only and :except options to specify which actions to
  # skip the effects on. It will apply to all actions by default.
  #
  #   class ProjectsController < ApplicationController
  #     load_and_authorize_resource
  #     skip_authorize_resource :only => :index
  #   end
  #
  # You can also pass the resource name as the first argument to skip that resource.
  #
  # source://cancancan//lib/cancan/controller_additions.rb#222
  def skip_authorize_resource(*args); end

  # Skip both the loading and authorization behavior of CanCan for this given controller. This is primarily
  # useful to skip the behavior of a superclass. You can pass :only and :except options to specify which actions
  # to skip the effects on. It will apply to all actions by default.
  #
  #   class ProjectsController < SomeOtherController
  #     skip_load_and_authorize_resource :only => :index
  #   end
  #
  # You can also pass the resource name as the first argument to skip that resource.
  #
  # source://cancancan//lib/cancan/controller_additions.rb#191
  def skip_load_and_authorize_resource(*args); end

  # Skip the loading behavior of CanCan. This is useful when using +load_and_authorize_resource+ but want to
  # only do authorization on certain actions. You can pass :only and :except options to specify which actions to
  # skip the effects on. It will apply to all actions by default.
  #
  #   class ProjectsController < ApplicationController
  #     load_and_authorize_resource
  #     skip_load_resource :only => :index
  #   end
  #
  # You can also pass the resource name as the first argument to skip that resource.
  #
  # source://cancancan//lib/cancan/controller_additions.rb#206
  def skip_load_resource(*args); end
end

# Handle the load and authorization controller logic
# so we don't clutter up all controllers with non-interface methods.
# This class is used internally, so you do not need to call methods directly on it.
#
# source://cancancan//lib/cancan/controller_resource.rb#6
class CanCan::ControllerResource
  include ::CanCan::ControllerResourceNameFinder
  include ::CanCan::ControllerResourceFinder
  include ::CanCan::ControllerResourceBuilder
  include ::CanCan::ControllerResourceSanitizer
  include ::CanCan::ControllerResourceLoader

  # @return [ControllerResource] a new instance of ControllerResource
  #
  # source://cancancan//lib/cancan/controller_resource.rb#23
  def initialize(controller, *args); end

  # source://cancancan//lib/cancan/controller_resource.rb#35
  def authorize_resource; end

  # source://cancancan//lib/cancan/controller_resource.rb#30
  def load_and_authorize_resource; end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/controller_resource.rb#40
  def parent?; end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/controller_resource.rb#44
  def skip?(behavior); end

  protected

  # source://cancancan//lib/cancan/controller_resource.rb#113
  def collection_actions; end

  # source://cancancan//lib/cancan/controller_resource.rb#100
  def collection_instance; end

  # source://cancancan//lib/cancan/controller_resource.rb#96
  def collection_instance=(instance); end

  # source://cancancan//lib/cancan/controller_resource.rb#109
  def instance_name; end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/controller_resource.rb#73
  def load_collection?; end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/controller_resource.rb#69
  def load_instance?; end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/controller_resource.rb#77
  def member_action?; end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/controller_resource.rb#105
  def parameters_require_sanitizing?; end

  # Returns the class used for this resource. This can be overriden by the :class option.
  # If +false+ is passed in it will use the resource name as a symbol in which case it should
  # only be used for authorization, not loading since there's no class to load through.
  #
  # source://cancancan//lib/cancan/controller_resource.rb#56
  def resource_class; end

  # source://cancancan//lib/cancan/controller_resource.rb#83
  def resource_class_with_parent; end

  # source://cancancan//lib/cancan/controller_resource.rb#91
  def resource_instance; end

  # source://cancancan//lib/cancan/controller_resource.rb#87
  def resource_instance=(instance); end

  # source://cancancan//lib/cancan/controller_resource.rb#117
  def save_actions; end

  private

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/controller_resource.rb#123
  def action_exists_in?(options); end

  # source://cancancan//lib/cancan/controller_resource.rb#127
  def adapter; end

  # source://cancancan//lib/cancan/controller_resource.rb#131
  def current_ability; end

  class << self
    # source://cancancan//lib/cancan/controller_resource.rb#9
    def add_before_action(controller_class, method, *args); end

    # source://cancancan//lib/cancan/controller_resource.rb#19
    def before_callback_name(options); end
  end
end

# source://cancancan//lib/cancan/controller_resource_builder.rb#2
module CanCan::ControllerResourceBuilder
  protected

  # source://cancancan//lib/cancan/controller_resource_builder.rb#10
  def assign_attributes(resource); end

  # source://cancancan//lib/cancan/controller_resource_builder.rb#5
  def build_resource; end

  # source://cancancan//lib/cancan/controller_resource_builder.rb#18
  def initial_attributes; end
end

# source://cancancan//lib/cancan/controller_resource_finder.rb#2
module CanCan::ControllerResourceFinder
  protected

  # source://cancancan//lib/cancan/controller_resource_finder.rb#19
  def find_by_dynamic_finder; end

  # source://cancancan//lib/cancan/controller_resource_finder.rb#24
  def find_by_find_by_finder; end

  # source://cancancan//lib/cancan/controller_resource_finder.rb#5
  def find_resource; end

  # source://cancancan//lib/cancan/controller_resource_finder.rb#15
  def find_resource_using_find_by; end

  # source://cancancan//lib/cancan/controller_resource_finder.rb#28
  def id_param; end

  # source://cancancan//lib/cancan/controller_resource_finder.rb#32
  def id_param_key; end
end

# source://cancancan//lib/cancan/controller_resource_loader.rb#6
module CanCan::ControllerResourceLoader
  include ::CanCan::ControllerResourceNameFinder
  include ::CanCan::ControllerResourceFinder
  include ::CanCan::ControllerResourceBuilder
  include ::CanCan::ControllerResourceSanitizer

  # source://cancancan//lib/cancan/controller_resource_loader.rb#12
  def load_resource; end

  protected

  # source://cancancan//lib/cancan/controller_resource_loader.rb#94
  def authorization_action; end

  # source://cancancan//lib/cancan/controller_resource_loader.rb#46
  def fetch_parent(name); end

  # source://cancancan//lib/cancan/controller_resource_loader.rb#98
  def load_collection; end

  # source://cancancan//lib/cancan/controller_resource_loader.rb#102
  def load_resource_instance; end

  # source://cancancan//lib/cancan/controller_resource_loader.rb#23
  def new_actions; end

  # source://cancancan//lib/cancan/controller_resource_loader.rb#90
  def parent_authorization_action; end

  # source://cancancan//lib/cancan/controller_resource_loader.rb#59
  def parent_name; end

  # The object to load this resource through.
  #
  # source://cancancan//lib/cancan/controller_resource_loader.rb#55
  def parent_resource; end

  # The object that methods (such as "find", "new" or "build") are called on.
  # If the :through option is passed it will go through an association on that instance.
  # If the :shallow option is passed it will use the resource_class if there's no parent
  # If the :singleton option is passed it won't use the association because it needs to be handled later.
  #
  # source://cancancan//lib/cancan/controller_resource_loader.rb#86
  def resource_base; end

  # source://cancancan//lib/cancan/controller_resource_loader.rb#71
  def resource_base_through; end

  # source://cancancan//lib/cancan/controller_resource_loader.rb#63
  def resource_base_through_parent_resource; end

  # source://cancancan//lib/cancan/controller_resource_loader.rb#38
  def resource_params; end

  # source://cancancan//lib/cancan/controller_resource_loader.rb#27
  def resource_params_by_key(key); end

  # source://cancancan//lib/cancan/controller_resource_loader.rb#32
  def resource_params_by_namespaced_name; end

  private

  # source://cancancan//lib/cancan/controller_resource_loader.rb#112
  def extract_key(value); end
end

# source://cancancan//lib/cancan/controller_resource_name_finder.rb#2
module CanCan::ControllerResourceNameFinder
  protected

  # source://cancancan//lib/cancan/controller_resource_name_finder.rb#13
  def name; end

  # source://cancancan//lib/cancan/controller_resource_name_finder.rb#5
  def name_from_controller; end

  # source://cancancan//lib/cancan/controller_resource_name_finder.rb#17
  def namespace; end

  # source://cancancan//lib/cancan/controller_resource_name_finder.rb#9
  def namespaced_name; end
end

# source://cancancan//lib/cancan/controller_resource_sanitizer.rb#2
module CanCan::ControllerResourceSanitizer
  protected

  # source://cancancan//lib/cancan/controller_resource_sanitizer.rb#22
  def params_method; end

  # source://cancancan//lib/cancan/controller_resource_sanitizer.rb#16
  def params_methods; end

  # source://cancancan//lib/cancan/controller_resource_sanitizer.rb#5
  def sanitize_parameters; end
end

# A general CanCan exception
#
# source://cancancan//lib/cancan/exceptions.rb#3
class CanCan::Error < ::StandardError; end

# Raised when removed code is called, an alternative solution is provided in message.
#
# source://cancancan//lib/cancan/exceptions.rb#9
class CanCan::ImplementationRemoved < ::CanCan::Error; end

# source://cancancan//lib/cancan/model_adapters/abstract_adapter.rb#2
module CanCan::ModelAdapters; end

# source://cancancan//lib/cancan/model_adapters/abstract_adapter.rb#3
class CanCan::ModelAdapters::AbstractAdapter
  # @return [AbstractAdapter] a new instance of AbstractAdapter
  #
  # source://cancancan//lib/cancan/model_adapters/abstract_adapter.rb#45
  def initialize(model_class, rules); end

  # @raise [NotImplemented]
  #
  # source://cancancan//lib/cancan/model_adapters/abstract_adapter.rb#50
  def database_records; end

  class << self
    # source://cancancan//lib/cancan/model_adapters/abstract_adapter.rb#9
    def adapter_class(model_class); end

    # Override if you need custom find behavior
    #
    # source://cancancan//lib/cancan/model_adapters/abstract_adapter.rb#19
    def find(model_class, id); end

    # Used to determine if the given adapter should be used for the passed in class.
    #
    # @return [Boolean]
    #
    # source://cancancan//lib/cancan/model_adapters/abstract_adapter.rb#14
    def for_class?(_member_class); end

    # @private
    #
    # source://cancancan//lib/cancan/model_adapters/abstract_adapter.rb#4
    def inherited(subclass); end

    # Override if override_condition_matching? returns true
    #
    # @raise [NotImplemented]
    # @return [Boolean]
    #
    # source://cancancan//lib/cancan/model_adapters/abstract_adapter.rb#41
    def matches_condition?(_subject, _name, _value); end

    # Override if override_conditions_hash_matching? returns true
    #
    # @raise [NotImplemented]
    # @return [Boolean]
    #
    # source://cancancan//lib/cancan/model_adapters/abstract_adapter.rb#30
    def matches_conditions_hash?(_subject, _conditions); end

    # Used to determine if this model adapter will override the matching behavior for a specific condition.
    # If this returns true then matches_condition? will be called. See Rule#matches_conditions_hash
    #
    # @return [Boolean]
    #
    # source://cancancan//lib/cancan/model_adapters/abstract_adapter.rb#36
    def override_condition_matching?(_subject, _name, _value); end

    # Used to determine if this model adapter will override the matching behavior for a hash of conditions.
    # If this returns true then matches_conditions_hash? will be called. See Rule#matches_conditions_hash
    #
    # @return [Boolean]
    #
    # source://cancancan//lib/cancan/model_adapters/abstract_adapter.rb#25
    def override_conditions_hash_matching?(_subject, _conditions); end
  end
end

# source://cancancan//lib/cancan/model_adapters/default_adapter.rb#3
class CanCan::ModelAdapters::DefaultAdapter < ::CanCan::ModelAdapters::AbstractAdapter; end

# This module adds the accessible_by class method to a model. It is included in the model adapters.
#
# source://cancancan//lib/cancan/model_additions.rb#3
module CanCan::ModelAdditions
  mixes_in_class_methods ::CanCan::ModelAdditions::ClassMethods

  class << self
    # @private
    #
    # source://cancancan//lib/cancan/model_additions.rb#26
    def included(base); end
  end
end

# source://cancancan//lib/cancan/model_additions.rb#4
module CanCan::ModelAdditions::ClassMethods
  # Returns a scope which fetches only the records that the passed ability
  # can perform a given action on. The action defaults to :index. This
  # is usually called from a controller and passed the +current_ability+.
  #
  #   @articles = Article.accessible_by(current_ability)
  #
  # Here only the articles which the user is able to read will be returned.
  # If the user does not have permission to read any articles then an empty
  # result is returned. Since this is a scope it can be combined with any
  # other scopes or pagination.
  #
  # An alternative action can optionally be passed as a second argument.
  #
  #   @articles = Article.accessible_by(current_ability, :update)
  #
  # Here only the articles which the user can update are returned.
  #
  # source://cancancan//lib/cancan/model_additions.rb#21
  def accessible_by(ability, action = T.unsafe(nil)); end
end

# Raised when behavior is not implemented, usually used in an abstract class.
#
# source://cancancan//lib/cancan/exceptions.rb#6
class CanCan::NotImplemented < ::CanCan::Error; end

# This class is used internally and should only be called through Ability.
# it holds the information about a "can" call made on Ability and provides
# helpful methods to determine permission checking and conditions hash generation.
#
# source://cancancan//lib/cancan/rule.rb#6
class CanCan::Rule
  include ::CanCan::ConditionsMatcher

  # The first argument when initializing is the base_behavior which is a true/false
  # value. True for "can" and false for "cannot". The next two arguments are the action
  # and subject respectively (such as :read, @project). The third argument is a hash
  # of conditions and the last one is the block passed to the "can" call.
  #
  # @raise [Error]
  # @return [Rule] a new instance of Rule
  #
  # source://cancancan//lib/cancan/rule.rb#15
  def initialize(base_behavior, action, subject, conditions, block); end

  # Returns the value of attribute actions.
  #
  # source://cancancan//lib/cancan/rule.rb#8
  def actions; end

  # source://cancancan//lib/cancan/rule.rb#58
  def associations_hash(conditions = T.unsafe(nil)); end

  # source://cancancan//lib/cancan/rule.rb#68
  def attributes_from_conditions; end

  # Returns the value of attribute base_behavior.
  #
  # source://cancancan//lib/cancan/rule.rb#8
  def base_behavior; end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/rule.rb#27
  def can_rule?; end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/rule.rb#31
  def cannot_catch_all?; end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/rule.rb#35
  def catch_all?; end

  # Returns the value of attribute conditions.
  #
  # source://cancancan//lib/cancan/rule.rb#8
  def conditions; end

  # Sets the attribute expanded_actions
  #
  # @param value the value to set the attribute expanded_actions to.
  #
  # source://cancancan//lib/cancan/rule.rb#9
  def expanded_actions=(_arg0); end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/rule.rb#45
  def only_block?; end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/rule.rb#49
  def only_raw_sql?; end

  # Matches both the subject and action, not necessarily the conditions
  #
  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/rule.rb#40
  def relevant?(action, subject); end

  # Returns the value of attribute subjects.
  #
  # source://cancancan//lib/cancan/rule.rb#8
  def subjects; end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/rule.rb#53
  def unmergeable?; end

  private

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/rule.rb#80
  def matches_action?(action); end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/rule.rb#84
  def matches_subject?(subject); end

  # @return [Boolean]
  #
  # source://cancancan//lib/cancan/rule.rb#88
  def matches_subject_class?(subject); end
end

# source://cancancan//lib/cancan/rules_compressor.rb#3
class CanCan::RulesCompressor
  # @return [RulesCompressor] a new instance of RulesCompressor
  #
  # source://cancancan//lib/cancan/rules_compressor.rb#6
  def initialize(rules); end

  # source://cancancan//lib/cancan/rules_compressor.rb#11
  def compress(array); end

  # Returns the value of attribute initial_rules.
  #
  # source://cancancan//lib/cancan/rules_compressor.rb#4
  def initial_rules; end

  # Returns the value of attribute rules_collapsed.
  #
  # source://cancancan//lib/cancan/rules_compressor.rb#4
  def rules_collapsed; end
end

# source://cancancan//lib/cancan/version.rb#2
CanCan::VERSION = T.let(T.unsafe(nil), String)

# Raised when using a wrong association name
#
# source://cancancan//lib/cancan/exceptions.rb#15
class CanCan::WrongAssociationName < ::CanCan::Error; end

# source://cancancan//lib/cancancan.rb#3
module CanCanCan; end
